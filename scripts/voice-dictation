#!/usr/bin/env python3
"""
Voice Dictation con DEBUG - Para encontrar el problema
"""

import subprocess
import os
import sys
import time
import signal
from pathlib import Path
import json

CACHE_DIR = Path.home() / '.cache' / 'voice-debug'
STATE_FILE = CACHE_DIR / 'state.json'
CONFIG_FILE = CACHE_DIR / 'config.json'

# Configuraci√≥n por defecto
DEFAULT_CONFIG = {
    'model': 'tiny',  # tiny, small, medium, large
    'language': 'es'
}

# Rutas de modelos disponibles
MODELS = {
    'tiny': "/home/miguel/src/whisper.cpp/models/ggml-tiny.bin",
    'small': "/home/miguel/src/whisper.cpp/models/ggml-small.bin",
    'medium': "/home/miguel/src/whisper.cpp/models/ggml-medium.bin",
    'large': "/home/miguel/src/whisper.cpp/models/ggml-large.bin"
}

WHISPER_CLI = "/home/miguel/src/whisper.cpp/build/bin/whisper-cli"

def load_config():
    """Carga configuraci√≥n o crea una por defecto"""
    if CONFIG_FILE.exists():
        try:
            with open(CONFIG_FILE) as f:
                return json.load(f)
        except:
            pass
    return DEFAULT_CONFIG

def save_config(config):
    """Guarda configuraci√≥n"""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=2)

def log(msg):
    """Debug log"""
    print(f"[DEBUG] {msg}")
    with open(CACHE_DIR / 'debug.log', 'a') as f:
        f.write(f"{time.ctime()}: {msg}\n")

def notify(message):
    """Notificaci√≥n con debug"""
    log(f"Notificaci√≥n: {message}")
    subprocess.run(['notify-send', 'Voice Dictation', message], check=False)

def is_recording():
    """Ve si hay grabaci√≥n activa"""
    log(f"Verificando si hay grabaci√≥n en {STATE_FILE}")
    if STATE_FILE.exists():
        try:
            with open(STATE_FILE) as f:
                data = json.load(f)
                pid = data.get('pid')
                log(f"PID encontrado en estado: {pid}")
                if pid:
                    try:
                        os.kill(pid, 0)
                        log(f"Proceso {pid} est√° activo")
                        return pid
                    except OSError:
                        log(f"Proceso {pid} ya no existe")
        except Exception as e:
            log(f"Error leyendo estado: {e}")
    else:
        log("Archivo de estado no existe")
    return None

def start_recording():
    """Inicia grabaci√≥n con debug"""
    log("=== INICIANDO GRABACI√ìN ===")
    
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    log(f"Directorio cache creado: {CACHE_DIR}")
    
    audio_file = CACHE_DIR / f'recording_{int(time.time())}.wav'
    log(f"Archivo de audio: {audio_file}")
    
    # Guardar estado con debug
    state_data = {
        'pid': os.getpid(),
        'audio_file': str(audio_file),
        'started': time.time()
    }
    
    with open(STATE_FILE, 'w') as f:
        json.dump(state_data, f, indent=2)
    log(f"Estado guardado: {state_data}")
    
    notify("üî¥ Grabando...")
    
    # Limpiar al salir - dar tiempo para que el archivo se escriba correctamente
    def cleanup(sig=None, frame=None):
        log("=== LIMPIEZA ===")
        # Esperar un poco m√°s para que ffmpeg termine de escribir
        time.sleep(1)
        if STATE_FILE.exists():
            log("Eliminando archivo de estado")
            STATE_FILE.unlink()
        # NO eliminar audio_file aqu√≠ - lo hace stop_recording despu√©s de transcribir
        log("Terminando proceso de grabaci√≥n")
        sys.exit(0)
    
    signal.signal(signal.SIGTERM, cleanup)
    signal.signal(signal.SIGINT, cleanup)
    
    # Activar micr√≥fono
    log("Activando micr√≥fono")
    result = subprocess.run(['pactl', 'set-source-mute', '@DEFAULT_SOURCE@', '0'], 
                          capture_output=True, text=True)
    log(f"Resultado activar micro: {result.returncode}")
    
    # GRABACI√ìN con ffmpeg optimizado
    cmd = [
        'ffmpeg',
        '-f', 'pulse',
        '-i', 'default',
        '-ar', '16000',
        '-ac', '1',
        '-acodec', 'pcm_s16le',  # Codec directo sin conversi√≥n
        '-fflags', 'nobuffer',    # Sin buffer para inicio r√°pido
        '-flags', 'low_delay',    # Baja latencia
        '-y',
        str(audio_file)
    ]
    
    log(f"Comando ffmpeg: {' '.join(cmd)}")
    
    try:
        log("Ejecutando ffmpeg...")
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        log(f"ffmpeg termin√≥ con c√≥digo: {result.returncode}")
    except subprocess.CalledProcessError as e:
        log(f"Error en ffmpeg: {e}")
        log(f"stderr: {e.stderr}")
        cleanup()
    except Exception as e:
        log(f"Error inesperado: {e}")
        cleanup()

def stop_recording():
    """Para grabaci√≥n con debug completo"""
    log("=== PARANDO GRABACI√ìN ===")
    
    if not STATE_FILE.exists():
        log("ERROR: Archivo de estado no existe")
        notify("‚ùå No hay grabaci√≥n activa")
        return
    
    try:
        with open(STATE_FILE) as f:
            data = json.load(f)
        log(f"Estado le√≠do: {data}")
        
        pid = data.get('pid')
        audio_file = Path(data.get('audio_file'))
        log(f"PID: {pid}, Archivo: {audio_file}")
        
        # Matar proceso
        if pid:
            log(f"Matando proceso {pid}")
            try:
                os.kill(pid, signal.SIGTERM)
                log("Se√±al SIGTERM enviada")
                time.sleep(3)  # Dar m√°s tiempo a ffmpeg para cerrar correctamente
            except Exception as e:
                log(f"Error matando proceso: {e}")
        
        # notify("üîÑ Procesando audio...")  # Comentado para reducir notificaciones
        
        # Verificar archivo
        if audio_file.exists():
            size = audio_file.stat().st_size
            log(f"Archivo existe, tama√±o: {size} bytes")
            
            if size > 1000:  # Al menos 1KB
                log("Archivo tiene tama√±o suficiente, transcribiendo...")
                # notify("üîÑ Transcribiendo...")  # Comentado - confunde al usuario
                
                # TRANSCRIBIR con modelo configurado
                config = load_config()
                model_path = MODELS.get(config['model'], MODELS['tiny'])
                
                cmd = [WHISPER_CLI, '-m', model_path, '-l', config['language'], 
                      '-f', str(audio_file), '-otxt', '--no-timestamps']
                
                log(f"Comando whisper: {' '.join(cmd)}")
                
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                log(f"Whisper termin√≥ con c√≥digo: {result.returncode}")
                log(f"Whisper stdout: {result.stdout[:200]}")
                log(f"Whisper stderr: {result.stderr[:200]}")
                
                if result.returncode == 0:
                    # Buscar archivo de texto
                    txt_file = audio_file.parent / (audio_file.name + '.txt')
                    log(f"Buscando archivo de texto: {txt_file}")
                    
                    if txt_file.exists():
                        with open(txt_file) as f:
                            text = f.read().strip()
                        log(f"Texto transcrito: '{text}' (longitud: {len(text)})")
                        
                        if text:
                            # COPIAR AL PORTAPAPELES
                            log("Copiando al portapapeles...")
                            try:
                                subprocess.run(['wl-copy'], input=text, text=True, check=True)
                                log("wl-copy exitoso")
                            except:
                                try:
                                    subprocess.run(['xsel', '-ib'], input=text, text=True, check=True)
                                    log("xsel exitoso")
                                except Exception as e:
                                    log(f"Error portapapeles: {e}")
                            
                            # Auto-pegar con la herramienta correcta para Wayland/X11
                            # (Comentado por ahora - descomentar si quieres auto-pegado)
                            # try:
                            #     session_type = os.environ.get('XDG_SESSION_TYPE', 'x11')
                            #     if session_type == 'wayland':
                            #         subprocess.run(['wtype', text], check=True)
                            #     else:
                            #         subprocess.run(['xdotool', 'type', text], check=True)
                            # except:
                            #     pass
                            
                            # Quitamos notificaci√≥n porque el popup es suficiente
                            
                            # POPUP con texto completo
                            try:
                                # Zenity info dialog con el texto completo
                                # Calculamos duraci√≥n en segundos
                                duration = len(text.split()) // 3  # Aprox 3 palabras por segundo de lectura
                                duration = max(5, min(duration, 30))  # Entre 5 y 30 segundos
                                
                                subprocess.run([
                                    'zenity', '--info',
                                    '--title=üé§ Dictado por voz - Texto en portapapeles',
                                    '--text=' + text,
                                    '--width=600',
                                    '--timeout=' + str(duration)
                                ], check=False)
                                log("Popup zenity mostrado")
                            except Exception as e:
                                log(f"Error mostrando popup: {e}")
                            
                            print(f"TEXTO FINAL: {text}")
                        else:
                            log("Texto vac√≠o")
                            notify("‚ö†Ô∏è No se detect√≥ voz")
                        
                        txt_file.unlink()
                        log("Archivo txt eliminado")
                    else:
                        log("ERROR: Archivo txt no encontrado")
                        notify("‚ùå Error en transcripci√≥n")
                else:
                    log("ERROR: Whisper fall√≥")
                    notify("‚ùå Error en whisper")
                
                audio_file.unlink()
                log("Archivo de audio eliminado")
            else:
                log(f"ERROR: Archivo muy peque√±o ({size} bytes)")
                notify("‚ùå Grabaci√≥n muy corta")
        else:
            log("ERROR: Archivo de audio no existe")
            notify("‚ùå Error: no se cre√≥ grabaci√≥n")
        
        if STATE_FILE.exists():
            STATE_FILE.unlink()
            log("Archivo de estado eliminado")
        else:
            log("Archivo de estado ya eliminado")
        log("=== FIN STOP ===")
        
    except Exception as e:
        log(f"ERROR GENERAL: {e}")
        # Simplificar mensaje de error para notificaci√≥n
        if "timed out" in str(e):
            notify("‚ùå Error: Transcripci√≥n tard√≥ demasiado")
        else:
            notify("‚ùå Error en transcripci√≥n")

def main():
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    
    # Limpiar log anterior
    log_file = CACHE_DIR / 'debug.log'
    if log_file.exists():
        log_file.unlink()
    
    log("=== INICIO SCRIPT DEBUG ===")
    
    # Verificar si hay comando especial
    if len(sys.argv) > 1:
        if sys.argv[1] == "config":
            # Configurar modelo
            if len(sys.argv) > 2:
                new_model = sys.argv[2]
                if new_model in MODELS:
                    config = load_config()
                    config['model'] = new_model
                    save_config(config)
                    notify(f"‚úÖ Modelo cambiado a: {new_model}")
                    print(f"Modelo cambiado a: {new_model}")
                else:
                    print(f"Modelos disponibles: {', '.join(MODELS.keys())}")
                    notify(f"‚ùå Modelo no v√°lido. Usa: {', '.join(MODELS.keys())}")
            else:
                config = load_config()
                print(f"Modelo actual: {config['model']}")
                print(f"Modelos disponibles: {', '.join(MODELS.keys())}")
            sys.exit(0)
    
    # Si se llama sin argumentos (desde GNOME), hacer toggle
    # Si se llama con argumentos, usar el argumento
    if len(sys.argv) > 1:
        action = sys.argv[1]
        log(f"Acci√≥n desde argumento: {action}")
        
        if action == "start":
            if is_recording():
                log("Ya hay grabaci√≥n activa")
                notify("‚ö†Ô∏è Ya hay una grabaci√≥n activa")
            else:
                start_recording()
        elif action == "stop":
            stop_recording()
    else:
        # Llamado sin argumentos - TOGGLE autom√°tico
        log("Llamado sin argumentos - modo toggle")
        if is_recording():
            log("Ya grabando - parando...")
            stop_recording()
        else:
            log("No grabando - iniciando...")
            start_recording()

if __name__ == "__main__":
    main()